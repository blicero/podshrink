# -*- mode: org; fill-column: 78; -*-
# Time-stamp: <2023-08-27 20:15:07 krylon>
#
#+TAGS: optimize(o) refactor(r) bug(b) feature(f) architecture(a)
#+TAGS: web(w) database(d) javascript(j) ui(u)
#+TODO: TODO(t) IMPLEMENT(i) TEST(e) RESEARCH(r) | DONE(d)
#+TODO: MEDITATE(m) PLANNING(p) REFINE(n) | FAILED(f) CANCELLED(c) SUSPENDED(s)
#+TODO: EXPERIMENT(x) |
#+PRIORITIES: A G D

* podshrink
  So, I'm a *very* enthusiastic podcast listener, and I'm also kind of a
  hoarder when it comes to data. Unfortunately, disk space is finite, and I
  was shocked one day to a) run out of disk space and b) discovered that
  downloaded podcast episodes accounted for about 60 percent of the used disk
  space.
  I also noted that a lot of podcasts are delivered in formats that aren't
  very considerate of network bandwidth or disk space. I get that people care
  about audio quality, but if a 60 minute episode takes up 90 Megabytes,
  something is very wrong. We're not talking about audiophile music recordings
  or surround sound. This is people talking. The MP3 revolution of the late
  1990s happened because MP3 provided decent audio quality for voice data at a
  bitrate that fit through an ISDN connection and decent quality for music (at
  least for non-audiophile people with affordable headphones or speakers) at
  about 1 Megabyte per minute. And since then, Vorbis and more recently
  Opus have managed to shrink audio data even further without sacrificing
  quality.
  So instead of going on a rant about free audio formats and podcasts, I
  decided to write a tool that converts my downloaded podcast files to opus,
  thus saving disk space.
  My first attempt was a Perl script, but that ended having a weird bug I
  didn't have the patience to fix, so I decided to do it all over again, this
  time in Go.
** Clocktable
   #+BEGIN: clocktable :scope file :maxlevel 20
   #+CAPTION: Clock summary at [2023-08-27 So 20:15]
   | Headline                  | Time    |       |      |
   |---------------------------+---------+-------+------|
   | *Total time*              | *13:53* |       |      |
   |---------------------------+---------+-------+------|
   | podshrink                 | 13:53   |       |      |
   | \_  Milestones [0/3]      |         | 13:53 |      |
   | \_    Walking directories |         |       | 5:49 |
   | \_    Metadata            |         |       | 8:04 |
   #+END:
** Journal
** Milestones [0/3]
   :PROPERTIES:
   :COOKIE_DATA: todo recursive
   :VISIBILITY: children
   :END:
*** TODO Walking directories
    :LOGBOOK:
    CLOCK: [2023-08-23 Mi 09:20]--[2023-08-23 Mi 10:24] =>  1:04
    CLOCK: [2023-08-22 Di 20:00]--[2023-08-22 Di 22:02] =>  2:02
    CLOCK: [2023-08-22 Di 17:35]--[2023-08-22 Di 19:45] =>  2:10
    CLOCK: [2023-08-17 Do 18:10]--[2023-08-17 Do 18:43] =>  0:33
    :END:
*** TODO Metadata
    :LOGBOOK:
    CLOCK: [2023-08-27 So 19:11]--[2023-08-27 So 20:14] =>  1:03
    CLOCK: [2023-08-26 Sa 20:04]--[2023-08-26 Sa 20:06] =>  0:02
    CLOCK: [2023-08-25 Fr 18:13]--[2023-08-25 Fr 23:30] =>  5:17
    CLOCK: [2023-08-24 Do 15:45]--[2023-08-24 Do 17:24] =>  1:39
    CLOCK: [2023-08-23 Mi 10:30]--[2023-08-23 Mi 10:33] =>  0:03
    :END:
    The Perl script I wrote initially didn't bother with metadata, which in
    retrospect was a big mistake. So one of the significant improvements is
    going to be extracting metadata from the original files and tagging the
    new files.
    I found a go library that claims to solve the first part of my problem:
    https://github.com/dhowden/tag
    From a first, superficial look, the API looks very nice.
*** TODO Convert [0/0]
    :PROPERTIES:
    :COOKIE_DATA: todo recursive
    :VISIBILITY: children
    :END:
    My original Perl script took a two-step approach: Convert the original
    audio file to WAV, then compress the WAV file to Opus. The reasoning was
    that opusenc(1) takes WAV files as its input, and not all decoders allow
    for writing WAV output to stdout. If they did, I could pipe the decoder's
    output directly to opusenc, saving a lot of disk space.
    In my original approach I created a RAM disk to store the WAV files, but
    if I could pipe all decoders' output to opusenc, I wouldn't need that at
    all. We'll see.
*** TODO Convert [0/0]
    :PROPERTIES:
    :COOKIE_DATA: todo recursive
    :VISIBILITY: children
    :END:
    My original Perl script took a two-step approach: Convert the original
    audio file to WAV, then compress the WAV file to Opus. The reasoning was
    that opusenc(1) takes WAV files as its input, and not all decoders allow
    for writing WAV output to stdout. If they did, I could pipe the decoder's
    output directly to opusenc, saving a lot of disk space.
    In my original approach I created a RAM disk to store the WAV files, but
    if I could pipe all decoders' output to opusenc, I wouldn't need that at
    all. We'll see.
** Components [0/0]
   :PROPERTIES:
   :COOKIE_DATA: todo recursive
   :VISIBILITY: children
   :END:
** Bugs [0/0]
   :PROPERTIES:
   :COOKIE_DATA: todo recursive
   :VISIBILITY: children
   :END:
   
